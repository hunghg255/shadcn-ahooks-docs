---
title: useMemoizedFn
description: Hooks for persistent functions. In general, useMemoizedFn can be used instead of useCallback. See [FAQ](#faq) for special cases.
---

## Overview

Hooks for persistent functions. In general, useMemoizedFn can be used instead of useCallback. See [FAQ](#faq) for special cases.

[Documentation and Examples](https://ahooks.js.org/hooks/use-memoizedfn)

## Installation

<OpenInV0Button url="https://shadcn-ahooks.vercel.app/r/useMemoizedFn.json" />

<Tabs items={['pnpm', 'npm', 'yarn', 'bun']}>
  <Tab value="pnpm">
  ```bash
  pnpm dlx shadcn@latest add https://shadcn-ahooks.vercel.app/r/useMemoizedFn.json
  ```
  </Tab>
  <Tab value="npm">
  ```bash
  npx shadcn@latest add https://shadcn-ahooks.vercel.app/r/useMemoizedFn.json
  ```
  </Tab>
  <Tab value="yarn">
  ```bash
  yarn shadcn@latest add https://shadcn-ahooks.vercel.app/r/useMemoizedFn.json
  ```
  </Tab>
  <Tab value="bun">
  ```bash
  bun shadcn@latest add https://shadcn-ahooks.vercel.app/r/useMemoizedFn.json
  ```
  </Tab>
</Tabs>

Hooks for persistent functions. In general, useMemoizedFn can be used instead of useCallback. See [FAQ](#faq) for special cases.

In some scenarios, we need to use useCallback to cache a function, but when the second parameter deps changes, the function will be regenerated, causing the function reference to change.

```js
const [state, setState] = useState('');

// When the state changes, the func reference will change
const func = useCallback(() => {
  console.log(state);
}, [state]);
```

Using useMemoizedFn, you can omit the second parameter deps, and ensure that the function reference never change.

```js
const [state, setState] = useState('');

// func reference never change
const func = useMemoizedFn(() => {
  console.log(state);
});
```

## Examples

### Default usage

<Preview name="useMemoizedFn"
 code={`
import useMemoizedFn from '@/src/hooks/ahooks/useMemoizedFn';
import React, { useState, useCallback } from 'react';

const Example = () => {
   const [count, setCount] = useState(0);

  const callbackFn = useCallback(() => {
    console.info(\`Current count is \${count}\`);
  }, [count]);

  const memoizedFn = useMemoizedFn(() => {
    console.info(\`Current count is \${count}\`);
  });

  return (
    <>
      <p>count: {count}</p>
      <button
        type="button"
        onClick={() => {
          setCount((c) => c + 1);
        }}
      >
        Add Count
      </button>
      <div style={{ marginTop: 16 }}>
        <button type="button" onClick={callbackFn}>
          call callbackFn
        </button>
        <button type="button" onClick={memoizedFn} style={{ marginLeft: 8 }}>
          call memoizedFn
        </button>
      </div>
    </>
  );
};

export default Example;`} />


### Performance Improvement


<Preview name="useMemoizedFn"
 code={`
import useMemoizedFn from '@/src/hooks/ahooks/useMemoizedFn';
import React, { useCallback, useRef, useState } from 'react';

// some expensive component with React.memo
const ExpensiveTree = React.memo<{ [key: string]: any }>(({ showCount }) => {
  const renderCountRef = useRef(0);
  renderCountRef.current += 1;

  return (
    <div>
      <p>Render Count: {renderCountRef.current}</p>
      <button type="button" onClick={showCount}>
        showParentCount
      </button>
    </div>
  );
});

const Example = () => {
   const [count, setCount] = useState(0);

  const callbackFn = useCallback(() => {
    console.info(\`Current count is \${count}\`);
  }, [count]);

  const memoizedFn = useMemoizedFn(() => {
    console.info(\`Current count is \${count}\`);
  });

  return (
    <>
      <p>count: {count}</p>
      <button
        type="button"
        onClick={() => {
          setCount((c) => c + 1);
        }}
      >
        Add Count
      </button>

      <p>You can click the button to see the number of sub-component renderings</p>

      <div style={{ marginTop: 32 }}>
        <h3>Component with useCallback function:</h3>
        {/* use callback function, ExpensiveTree component will re-render on state change */}
        <ExpensiveTree showCount={callbackFn} />
      </div>

      <div style={{ marginTop: 32 }}>
        <h3>Component with useMemoizedFn function:</h3>
        {/* use memoized function, ExpensiveTree component will only render once */}
        <ExpensiveTree showCount={memoizedFn} />
      </div>
    </>
  );
};

export default Example;`} />

## API

```typescript
const memoizedFn = useMemoizedFn<T>(fn: T): T;
```

### Result

| Property   | Description                                       | Type                      |
| ---------- | ------------------------------------------------- | ------------------------- |
| memoizedFn | Function that the reference address never changes | `(...args: any[]) => any` |

### Params

| Property | Description                       | Type                      | Default |
| -------- | --------------------------------- | ------------------------- | ------- |
| fn       | Function that require persistence | `(...args: any[]) => any` | -       |

## FAQ

### The function returned by `useMemoizedFn` will not inherit properties from fn itself?

The function returned by `useMemoizedFn` is entirely different from the reference of the passed `fn`, and it does not inherit any properties from `fn` itself. If you want to preserve the properties of the function itself after memoization, `useMemoizedFn` currently does not fulfill that requirement. In this case, consider downgrading to using `useCallback` or `useMemo` instead.

Related issues: [2273](https://github.com/alibaba/hooks/issues/2273)
