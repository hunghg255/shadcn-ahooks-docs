---
title: Basic usage
description: The API useRequest
---

# Basic usage

In this section, we will introduce the core and basic functionalities of `useRequest`, that is, the functionalities of the `useRequest` kernel.


## Default request

By default, the first parameter of `useRequest` is an asynchronous function, which is automatically executed when the component is initialized. At the same time, it automatically manages the status of `loading`, `data`, `error` of the asynchronous function.

```js
const { data, error, loading } = useRequest(service);
```

<br />

<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';

function getUsername(): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve('John Doe');
      } else {
        reject(new Error('Failed to get username'));
      }
    }, 1000);
  });
}

const Example = () => {
  const { data, error, loading } = useRequest(getUsername);

  if (error) {
    return <div>{error.message}</div>;
  }
  if (loading) {
    return <div>loading...</div>;
  }
  return <div>Username: {data}</div>;
};

export default Example;`} />


## Manually trigger

If `options.manual = true` is set, `useRequest` will not be executed by default, and the execution needs to be triggered by `run` or `runAsync`.

```tsx | pure
const { loading, run, runAsync } = useRequest(service, {
  manual: true
});

<button onClick={run} disabled={loading}>
  {loading ? 'Loading' : 'Edit'}
</button>
```

The difference between `run` and `runAsync` is:

- `run` is a normal synchronous function, we will automatically catch the exception, you can use `options.onError` to handle the behavior of the exception.
- `runAsync` is a asynchronous function that returns a `Promise`. If you use `runAsync` to call it, it means you need to catch the exception yourself.

  ```ts
  runAsync().then((data) => {
    console.log(data);
  }).catch((error) => {
    console.log(error);
  })
  ```

Next, we will demonstrate the difference between `run` and `runAsync` through the simple scenario of editing the username.

In this example, we use run(username) to edit the username, and use onSuccess and onError to handle success and failure.


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import { useState } from 'react';

function changeUsername(username: string): Promise<{ success: boolean }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ success: true });
    }, 1000);
  });
}


const Example = () => {
   const [state, setState] = useState('');

  const { loading, run } = useRequest(changeUsername, {
    manual: true,
    onSuccess: (result, params) => {
      if (result.success) {
        setState('');
        console.log(\`Username changed to: \${params[0]}\`);
      }
    },
  });

  return (
    <div>
      <input
        onChange={(e) => setState(e.target.value)}
        value={state}
        placeholder="Please enter username"
        style={{ width: 240, marginRight: 16 }}
      />
      <button disabled={loading} type="button" onClick={() => run(state)}>
        {loading ? 'Loading' : 'Edit'}
      </button>
    </div>
  );
};

export default Example;`} />



In this example, we use runAsync(username) to edit the user name. At this time, we must catch the exception through catch.


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import { useState } from 'react';

function changeUsername(username: string): Promise<{ success: boolean }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ success: true });
    }, 1000);
  });
}


const Example = () => {
   const [state, setState] = useState('');

  const { loading, runAsync } = useRequest(changeUsername, {
    manual: true
  });

   const onClick = async () => {
    try {
      await runAsync(state);
      setState('');
      console.log(\`Username changed to: \${state}\`);
    } catch (error) {
      console.log(error.message);
    }
  };

  return (
    <div>
      <input
        onChange={(e) => setState(e.target.value)}
        value={state}
        placeholder="Please enter username"
        style={{ width: 240, marginRight: 16 }}
      />
      <button disabled={loading} type="button" onClick={onClick}>
        {loading ? 'Loading' : 'Edit'}
      </button>
    </div>
  );
};

export default Example;`} />

## The life cycle

`useRequest` provides the following life cycle for you to do some processing in different stages of asynchronous functions.

- `onBefore`: Triggered before the request
- `onSuccess`: Triggered when the request is resolved
- `onError`: Triggered when the request is rejected
- `onFinally`: Triggered when the request is completed


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import React, { useState } from 'react';

function editUsername(username: string): Promise<void> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve();
      } else {
        reject(new Error('Failed to modify username'));
      }
    }, 1000);
  });
}

const Example = () => {
  const [state, setState] = useState('');

  const { loading, run } = useRequest(editUsername, {
    manual: true,
    onBefore: (params) => {
      console.info(\`Start Request: \${params[0]}\`);
    },
    onSuccess: (result, params) => {
      setState('');
      console.log(\`The username was changed to "\${params[0]}" !\`);
    },
    onError: (error) => {
      console.error(error.message);
    },
    onFinally: (params, result, error) => {
      console.info(\`Request finish\`);
    },
  });

  return (
    <div>
      <input
        onChange={(e) => setState(e.target.value)}
        value={state}
        placeholder="Please enter username"
        style={{ width: 240, marginRight: 16 }}
      />
      <button disabled={loading} type="button" onClick={() => run(state)}>
        {loading ? 'Loading' : 'Edit'}
      </button>
    </div>
  );
};

export default Example;`} />

## Refresh (repeat the last request)

`useRequest` provides the `refresh` and `refreshAsync` methods so that we can use the last parameters to re-run the request.

If in the scenario of reading user information

1. We read the user information with ID 1 `run(1)`
2. We updated user information by some ways
3. We want to re-initiate the last request, then we can use `refresh` instead of `run(1)`, which is very useful in scenarios with complex parameters


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import Mock from 'mockjs';
import React, { useEffect } from 'react';

function getUsername(id: number): Promise<string> {
  console.log('use-request-refresh-id', id);
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(Mock.mock('@name'));
    }, 1000);
  });
}


const Example = () => {
    const { data, loading, run, refresh } = useRequest((id: number) => getUsername(id), {
    manual: true,
  });

  useEffect(() => {
    run(1);
  }, []);

  if (loading) {
    return <div>loading...</div>;
  }
  return (
    <div>
      <p>Username: {data}</p>
      <button onClick={refresh} type="button">
        Refresh
      </button>
    </div>
  );
};

export default Example;`} />

Of course, the difference between `refresh` and `refreshAsync` is the same as `run` and `runAsync`.

## Change data immediately

`useRequest` provides `mutate`, which can immediate modify the `data`.

The usage of `mutate` is consistent with `React.setState`, supports: `mutate(newData)` and `mutate((oldData) => newData)`.

In the following example, we demonstrate a scenario of `mutate`.

We have modified the user name, but we do not want to wait for the request to be successful before giving feedback to the user. Instead, modify the data directly, then call the modify request in background, and provide additional feedback after the request returns.


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import Mock from 'mockjs';
import React, { useState, useRef } from 'react';

function getUsername(): Promise<string> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(Mock.mock('@name'));
    }, 1000);
  });
}

function editUsername(username: string): Promise<void> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve();
      } else {
        reject(new Error('Failed to modify username'));
      }
    }, 1000);
  });
}

const Example = () => {
  // store last username
  const lastRef = useRef<string>();

  const [state, setState] = useState('');

  // get username
  const { data: username, mutate } = useRequest(getUsername);

  // edit username
  const { run: edit } = useRequest(editUsername, {
    manual: true,
    onSuccess: (result, params) => {
      setState('');
      console.log(\`The username was changed to "\${params[0]}" !\`);
    },
    onError: (error) => {
      console.error(error.message);
      mutate(lastRef.current);
    },
  });

  const onChange = () => {
    lastRef.current = username;
    mutate(state);
    edit(state);
  };

  return (
    <div>
      <p>Username: {username}</p>
      <input
        onChange={(e) => setState(e.target.value)}
        value={state}
        placeholder="Please enter username"
        style={{ width: 240, marginRight: 16 }}
      />
      <button type="button" onClick={onChange}>
        Edit
      </button>
    </div>
  );
};

export default Example;`} />

## Cancel response

`useRequest` provides a `cancel` function, which will **ignore** the data and error returned by the current promise

**Note: Calling `cancel` doesn't cancel the execution of promise**

At the same time, `useRequest` will automatically ignore the response at the following timing:

- When the component is unmounting, the ongoing promise
- Race cancellation, when the previous promise has not returned, if the next promise is initiated, the previous promise will be ignored


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import Mock from 'mockjs';
import React, { useState } from 'react';

function editUsername(username: string): Promise<void> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve();
      } else {
        reject(new Error('Failed to modify username'));
      }
    }, 1000);
  });
}



const Example = () => {
   const [state, setState] = useState('');

  const { loading, run, cancel } = useRequest(editUsername, {
    manual: true,
    onSuccess: (result, params) => {
      setState('');
      console.log(\`The username was changed to "\${params[0]}" !\`);
    },
    onError: (error) => {
      console.error(error.message);
    },
  });

  return (
    <div>
      <input
        onChange={(e) => setState(e.target.value)}
        value={state}
        placeholder="Please enter username"
        style={{ width: 240, marginRight: 16 }}
      />
      <button disabled={loading} type="button" onClick={() => run(state)}>
        {loading ? 'Loading' : 'Edit'}
      </button>
      <button type="button" onClick={cancel} style={{ marginLeft: 16 }}>
        Cancel
      </button>
    </div>
  );
};

export default Example;`} />

## Parameter management

The `params` returned by `useRequest` will record the parameters of `service`. For example, if you trigger `run(1, 2, 3)`, then `params` is equal to `[1, 2, 3]`.

If we set `options.manual = false`, the parameters of calling `service` for the first time can be set by `options.defaultParams`.


<Preview name="useRequest" code={`

import useRequest from '@/src/hooks/ahooks/useRequest';
import Mock from 'mockjs';
import React, { useState } from 'react';

function getUsername(id: string): Promise<string> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(Mock.mock('@name'));
    }, 1000);
  });
}

const Example = () => {
   const [state, setState] = useState('');

  // get username
  const {
    data: username,
    run,
    params,
  } = useRequest(getUsername, {
    defaultParams: ['1'],
  });

  const onChange = () => {
    run(state);
  };

  return (
    <div>
      <input
        onChange={(e) => setState(e.target.value)}
        value={state}
        placeholder="Please enter userId"
        style={{ width: 240, marginRight: 16 }}
      />
      <button type="button" onClick={onChange}>
        GetUserName
      </button>
      <p style={{ marginTop: 8 }}>UserId: {params[0]}</p>
      <p>Username: {username}</p>
    </div>
  );
};

export default Example;`} />

## API

```ts
const {
  loading: boolean,
  data?: TData,
  error?: Error,
  params: TParams || [],
  run: (...params: TParams) => void,
  runAsync: (...params: TParams) => Promise<TData>,
  refresh: () => void,
  refreshAsync: () => Promise<TData>,
  mutate: (data?: TData | ((oldData?: TData) => (TData | undefined))) => void,
  cancel: () => void,
} = useRequest<TData, TParams>(
  service: (...args: TParams) => Promise<TData>,
  {
    manual?: boolean,
    defaultParams?: TParams,
    onBefore?: (params: TParams) => void,
    onSuccess?: (data: TData, params: TParams) => void,
    onError?: (e: Error, params: TParams) => void,
    onFinally?: (params: TParams, data?: TData, e?: Error) => void,
  }
);
```

### Result

| Property     | Description                                                                                                                                                                             | Type                                                                  |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| data         | Data returned by service                                                                                                                                                                | `TData` \| `undefined`                                                |
| error        | Exception thrown by service                                                                                                                                                             | `Error` \| `undefined`                                                |
| loading      | Is the service being executed                                                                                                                                                           | `boolean`                                                             |
| params       | An array of parameters for the service being executed. For example, you triggered `run(1, 2, 3)`, then params is equal to `[1, 2, 3]`                                                   | `TParams` \| `[]`                                                     |
| run          | <ul><li> Manually trigger the execution of the service, and the parameters will be passed to the service</li><li>Automatic handling of exceptions, feedback through `onError`</li></ul> | `(...params : TParams) => void`                                       |
| runAsync     | The usage is the same as `run`, but it returns a Promise, so you need to handle the exception yourself.                                                                                 | `(...params: TParams) => Promise<TData>`                              |
| refresh      | Use the last params, call `run` again                                                                                                                                                   | `() => void`                                                          |
| refreshAsync | Use the last params, call `runAsync` again                                                                                                                                              | `() => Promise<TData>`                                                |
| mutate       | Mutate `data` directly                                                                                                                                                                  | `(data?: TData / ((oldData?: TData) => (TData / undefined))) => void` |
| cancel       | Ignore the current promise response                                                                                                                                                     | `() => void`                                                          |

### Options

| Property      | Description                                                                                                                                                                                                      | Type                                                 | Default |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | ------- |
| manual        | <ul><li> The default is `false`. That is, the service is automatically executed during initialization. </li><li>If set to `true`, you need to manually call `run` or `runAsync` to trigger execution. </li></ul> | `boolean`                                            | `false` |
| defaultParams | The parameters passed to the service at the first default execution                                                                                                                                              | `TParams`                                            | -       |
| onBefore      | Triggered before service execution                                                                                                                                                                               | `(params: TParams) => void`                          | -       |
| onSuccess     | Triggered when service resolve                                                                                                                                                                                   | `(data: TData, params: TParams) => void`             | -       |
| onError       | Triggered when service reject                                                                                                                                                                                    | `(e: Error, params: TParams) => void`                | -       |
| onFinally     | Triggered when service execution is complete                                                                                                                                                                     | `(params: TParams, data?: TData, e?: Error) => void` | -       |

Above we have introduced the most basic functionalities of useRequest, and then we will introduce some more advanced functionalities.
