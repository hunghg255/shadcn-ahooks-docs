---
title: useInfiniteScroll
description: useInfiniteScroll encapsulates the common infinite scroll logic.
---

## Overview

useInfiniteScroll encapsulates the common infinite scroll logic.

[Documentation and Examples](https://ahooks.js.org/hooks/use-infinitescroll)

## Installation

<OpenInV0Button url="https://shadcn-ahooks.vercel.app/r/useInfiniteScroll.json" />

<Tabs items={['pnpm', 'npm', 'yarn', 'bun']}>
  <Tab value="pnpm">
  ```bash
  pnpm dlx shadcn@latest add https://shadcn-ahooks.vercel.app/r/useInfiniteScroll.json
  ```
  </Tab>
  <Tab value="npm">
  ```bash
  npx shadcn@latest add https://shadcn-ahooks.vercel.app/r/useInfiniteScroll.json
  ```
  </Tab>
  <Tab value="yarn">
  ```bash
  yarn shadcn@latest add https://shadcn-ahooks.vercel.app/r/useInfiniteScroll.json
  ```
  </Tab>
  <Tab value="bun">
  ```bash
  bun shadcn@latest add https://shadcn-ahooks.vercel.app/r/useInfiniteScroll.json
  ```
  </Tab>
</Tabs>

useInfiniteScroll encapsulates the common infinite scroll logic.

```js
const { data, loading, loadingMore, loadMore } = useInfiniteScroll(service);
```

The first parameter `service` of useInfiniteScroll is an asynchronous function. The input and output parameters of this function have the following conventions:

1. The data returned by `service` must contain a `list` array, the type is `{ list: any[], ...rest }`
2. The input parameter of `service` is the latest merged `data`

If the data returned for the first request is `{ list: [1, 2, 3], nextId: 4 }`, the data returned for the second time is `{ list: [4, 5, 6], nextId: 7 }` , then we will automatically merge `list`, and the merged `data` will be `{ list: [1, 2, 3, 4, 5, 6], nextId: 7 }`.

## Basic usage

In the first example, we demonstrate the implementation of a most basic infinite scroll.

<Preview name="useInfiniteScroll"
 code={`
import useInfiniteScroll from '@/src/hooks/ahooks/useInfiniteScroll';
import React, { useRef } from 'react';

interface Result {
  list: string[];
  nextId: string | undefined;
}

const resultData = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13'];

function getLoadMoreList(nextId: string | undefined, limit: number): Promise<Result> {
  let start = 0;
  if (nextId) {
    start = resultData.findIndex((i) => i === nextId);
  }
  const end = start + limit;
  const list = resultData.slice(start, end);
  const nId = resultData.length >= end ? resultData[end] : undefined;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        list,
        nextId: nId,
      });
    }, 1000);
  });
}


const Example = () => {
  const { data, loading, loadMore, loadingMore } = useInfiniteScroll((d) =>
    getLoadMoreList(d?.nextId, 4),
  );

  return (
    <div>
      {loading ? (
        <p>loading</p>
      ) : (
        <div>
          {data?.list?.map((item) => (
            <div key={item} style={{ padding: 12, border: '1px solid #f5f5f5' }}>
              item-{item}
            </div>
          ))}
        </div>
      )}

      <div style={{ marginTop: 8 }}>
        {data?.nextId && (
          <button type="button" onClick={loadMore} disabled={loadingMore}>
            {loadingMore ? 'Loading more...' : 'Click to load more'}
          </button>
        )}

        {!data?.nextId && <span>No more data</span>}
      </div>
    </div>
  );
};

export default Example;`} />


## Pagination

In the data fixation scenario, we sometimes use `page` and `pageSize` to request new data.


<Preview name="useInfiniteScroll"
 code={`
import useInfiniteScroll from '@/src/hooks/ahooks/useInfiniteScroll';
import React, { useRef } from 'react';

interface Result {
  list: string[];
  total: number;
}

const resultData = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13'];

function getLoadMoreList(page: number, pageSize: number): Promise<Result> {
  const start = (page - 1) * pageSize;
  const end = page * pageSize;
  const list = resultData.slice(start, end);
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        list,
        total: resultData.length,
      });
    }, 1000);
  });
}

const PAGE_SIZE = 4;

const Example = () => {
 const { data, loading, loadMore, loadingMore } = useInfiniteScroll((d) => {
    const page = d ? Math.ceil(d.list.length / PAGE_SIZE) + 1 : 1;
    return getLoadMoreList(page, PAGE_SIZE);
  });

  const hasMore = data && data.list.length < data.total;

  return (
    <div>
      {loading ? (
        <p>loading</p>
      ) : (
        <div>
          {data?.list?.map((item) => (
            <div key={item} style={{ padding: 12, border: '1px solid #f5f5f5' }}>
              item-{item}
            </div>
          ))}
        </div>
      )}

      <div style={{ marginTop: 8 }}>
        {hasMore && (
          <button type="button" onClick={loadMore} disabled={loadingMore}>
            {loadingMore ? 'Loading more...' : 'Click to load more'}
          </button>
        )}

        {!hasMore && <span>No more data</span>}
      </div>
    </div>
  );
};

export default Example;`} />

## Scrolling to automatically load

In the infinite scrolling scenario, the most common case is to automatically load when scrolling to the bottom. By configuring the following properties, you can achieve scrolling to automatically load.

- `options.target` specifies the parent element, The parent element needs to set a fixed height and support internal scrolling
- `options.isNoMore` determines if there is no more data
- `options.direction` determines the direction of scrolling, the default is `bottom`

the scroll to bottom demo

<Preview name="useInfiniteScroll"
 code={`
import useInfiniteScroll from '@/src/hooks/ahooks/useInfiniteScroll';
import React, { useRef } from 'react';


interface Result {
  list: string[];
  nextId: string | undefined;
}

const resultData = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13'];

function getLoadMoreList(nextId: string | undefined, limit: number): Promise<Result> {
  let start = 0;
  if (nextId) {
    start = resultData.findIndex((i) => i === nextId);
  }
  const end = start + limit;
  const list = resultData.slice(start, end);
  const nId = resultData.length >= end ? resultData[end] : undefined;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        list,
        nextId: nId,
      });
    }, 1000);
  });
}

const Example = () => {
  const ref = useRef<HTMLDivElement>(null);

  const { data, loading, loadMore, loadingMore, noMore } = useInfiniteScroll(
    (d) => getLoadMoreList(d?.nextId, 4),
    {
      target: ref,
      isNoMore: (d) => d?.nextId === undefined,
    },
  );

  return (
    <div ref={ref} style={{ height: 150, overflow: 'auto', border: '1px solid', padding: 12 }}>
      {loading ? (
        <p>loading</p>
      ) : (
        <div>
          {data?.list?.map((item) => (
            <div key={item} style={{ padding: 12, border: '1px solid #f5f5f5' }}>
              item-{item}
            </div>
          ))}
        </div>
      )}

      <div style={{ marginTop: 8 }}>
        {!noMore && (
          <button type="button" onClick={loadMore} disabled={loadingMore}>
            {loadingMore ? 'Loading more...' : 'Click to load more'}
          </button>
        )}

        {noMore && <span>No more data</span>}
      </div>
    </div>
  );
};

export default Example;`} />

the scroll to top demo


<Preview name="useInfiniteScroll"
 code={`
import useInfiniteScroll from '@/src/hooks/ahooks/useInfiniteScroll';
import React, { useRef } from 'react';


interface Result {
  list: string[];
  nextId: string | undefined;
}

const resultData = [
  '15',
  '14',
  '13',
  '12',
  '11',
  '10',
  '9',
  '8',
  '7',
  '6',
  '5',
  '4',
  '3',
  '2',
  '1',
  '0',
];

function getLoadMoreList(nextId: string | undefined, limit: number): Promise<Result> {
  let start = 0;
  if (nextId) {
    start = resultData.findIndex((i) => i === nextId);
  }
  const end = start + limit;
  const list = resultData.slice(start, end).reverse();
  const nId = resultData.length >= end ? resultData[end] : undefined;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        list,
        nextId: nId,
      });
    }, 1000);
  });
}

const Example = () => {
   const ref = useRef<HTMLDivElement>(null);
  const isFirstIn = useRef(true);

  const { data, loading, loadMore, loadingMore, noMore } = useInfiniteScroll(
    (d) => getLoadMoreList(d?.nextId, 5),
    {
      target: ref,
      direction: 'top',
      threshold: 0,
      isNoMore: (d) => d?.nextId === undefined,
      onSuccess() {
        if (isFirstIn.current) {
          isFirstIn.current = false;
          setTimeout(() => {
            const el = ref.current;
            if (el) {
              el.scrollTo(0, 999999);
            }
          });
        }
      },
    },
  );

  return (
    <div ref={ref} style={{ height: 150, overflow: 'auto', border: '1px solid', padding: 12 }}>
      {loading ? (
        <p>loading</p>
      ) : (
        <div>
          <div style={{ marginBottom: 10 }}>
            {!noMore && (
              <button type="button" onClick={loadMore} disabled={loadingMore}>
                {loadingMore ? 'Loading more...' : 'Click to load more'}
              </button>
            )}

            {noMore && <span>No more data</span>}
          </div>
          {data?.list?.map((item) => (
            <div key={item} style={{ padding: 12, border: '1px solid #f5f5f5' }}>
              item-{item}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default Example;`} />


## Data reset

The data can be reset by `reload`. The following example shows that after the `filter` changes, the data is reset to the first page.


<Preview name="useInfiniteScroll"
 code={`
import useInfiniteScroll from '@/src/hooks/ahooks/useInfiniteScroll';
import React, { useState } from 'react';


interface Result {
  list: string[];
  nextId: string | undefined;
}

const resultData = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13'];

function getLoadMoreList(
  nextId: string | undefined,
  limit: number,
  keyword: string,
): Promise<Result> {
  let start = 0;
  if (nextId) {
    start = resultData.findIndex((i) => i === nextId);
  }
  const end = start + limit;
  const list = resultData.slice(start, end);
  const nId = resultData.length >= end ? resultData[end] : undefined;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        list,
        nextId: nId,
      });
    }, 1000);
  });
}

const Example = () => {
  const [keyword, setKeyword] = useState('');

  const { data, loading, loadMore, loadingMore, reload } = useInfiniteScroll((d) =>
    getLoadMoreList(d?.nextId, 4, keyword),
  );

  return (
    <div>
      <div style={{ marginBottom: 16 }}>
        <input value={keyword} onChange={(e) => setKeyword(e.target.value)} />
        <button style={{ marginLeft: 8 }} onClick={reload}>
          Filter
        </button>
      </div>
      {loading ? (
        <p>loading</p>
      ) : (
        <div>
          {data?.list?.map((item) => (
            <div key={item} style={{ padding: 12, border: '1px solid #f5f5f5' }}>
              item-{item}
            </div>
          ))}
        </div>
      )}

      <div style={{ marginTop: 8 }}>
        {data?.nextId && (
          <button type="button" onClick={loadMore} disabled={loadingMore}>
            {loadingMore ? 'Loading more...' : 'Click to load more'}
          </button>
        )}

        {!data?.nextId && <span>No more data</span>}
      </div>
    </div>
  );
};

export default Example;`} />

The above code can be implemented with `reloadDeps` syntax sugar. When `reloadDeps` changes, `reload` will be triggered automatically.

```ts
const result = useInfiniteScroll(service, {
  reloadDeps: [keyword]
});
```

## Data mutation

With `mutate`, we can directly modify the current `data`. The following example demonstrates deleting a record from the data.



<Preview name="useInfiniteScroll"
registryDependencies={['useRequest']}
 code={`
import useInfiniteScroll from '@/src/hooks/ahooks/useInfiniteScroll';
import useRequest from '@/src/hooks/ahooks/useRequest';
import React, { useState } from 'react';

interface Result {
  list: string[];
  nextId: string | undefined;
}

const resultData = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13'];

function getLoadMoreList(nextId: string | undefined, limit: number): Promise<Result> {
  let start = 0;
  if (nextId) {
    start = resultData.findIndex((i) => i === nextId);
  }
  const end = start + limit;
  const list = resultData.slice(start, end);
  const nId = resultData.length >= end ? resultData[end] : undefined;
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        list,
        nextId: nId,
      });
    }, 1000);
  });
}

function deleteItem(id: string) {
  return new Promise<void>((resolve) => {
    setTimeout(() => {
      resolve();
    }, 1000);
  });
}

const Example = () => {
  const { data, loading, loadMore, loadingMore, mutate } = useInfiniteScroll((d) =>
    getLoadMoreList(d?.nextId, 4),
  );

  const {
    loading: deleteLading,
    params: deleteParams,
    run: remove,
  } = useRequest(deleteItem, {
    manual: true,
    onSuccess: (_, [id]) => {
      if (data) {
        const index = data.list.findIndex((i) => i === id);
        data?.list.splice(index, 1);
        mutate({ ...data });
      }
    },
  });

  return (
    <div>
      {loading ? (
        <p>loading</p>
      ) : (
        <div>
          {data?.list?.map((item) => (
            <div key={item} style={{ padding: 12, border: '1px solid #f5f5f5' }}>
              item-{item}
              <button
                style={{ marginLeft: 8 }}
                onClick={() => remove(item)}
                disabled={deleteLading && deleteParams[0] === item}
              >
                Delete
              </button>
            </div>
          ))}
        </div>
      )}

      <div style={{ marginTop: 8 }}>
        {data?.nextId && (
          <button type="button" onClick={loadMore} disabled={loadingMore}>
            {loadingMore ? 'Loading more...' : 'Click to load more'}
          </button>
        )}

        {!data?.nextId && <span>No more data</span>}
      </div>
    </div>
  );
};

export default Example;`} />

## API

```ts
export type Data = { list: any[];[key: string]: any; };
export type Service<TData extends Data> = (currentData?: TData) => Promise<TData>;

const {
  data: TData;
  loading: boolean;
  loadingMore: boolean;
  error?: Error;
  noMore: boolean;
  loadMore: () => void;
  loadMoreAsync: () => Promise<TData>;
  reload: () => void;
  reloadAsync: () => Promise<TData>;
  cancel: () => void;
  mutate: (data?: TData) => void;
} = useInfiniteScroll<TData extends Data>(
  service: (currentData?: TData) => Promise<TData>,
  {
    target?: BasicTarget;
    isNoMore?: (data?: TData) => boolean;
    threshold?: number;
    manual?: boolean;
    reloadDeps?: DependencyList;
    onBefore?: () => void;
    onSuccess?: (data: TData) => void;
    onError?: (e: Error) => void;
    onFinally?: (data?: TData, e?: Error) => void;
  }
);
```

### Result

| Property      | Description                                                                                                                                       | Type                     |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| data          | The data returned by the service, where the `list` attribute is the aggregated data                                                               | `TData` \| `undefined`   |
| loading       | Is the first request in progress                                                                                                                  | `boolean`                |
| loadingMore   | Is more data request in progress                                                                                                                  | `boolean`                |
| noMore        | Whether there is no more data, it will take effect after configuring `options.isNoMore`                                                           | `boolean`                |
| error         | Request error message                                                                                                                             | `Error`                  |
| loadMore      | Load more data, it will automatically catch the exception, and handle it through `options.onError`                                                | `() => void`             |
| loadMoreAsync | Load more data, which is consistent with the behavior of `loadMore`, but returns Promise, so you need to handle the exception yourself            | `() => Promise<TData>`   |
| reload        | Load the first page of data, it will automatically catch the exception, and handle it through `options.onError`                                   | `() => void`             |
| reloadAsync   | Load the first page of data, which is consistent with the behavior of `reload`, but returns Promise, so you need to handle the exception yourself | `() => Promise<TData>`   |
| mutate        | Modify `data` directly                                                                                                                            | `(data?: TData) => void` |
| cancel        | Ignore the current promise response                                                                                                               | `() => void`             |

### Options

| Property   | Description                                                                                                                                                                                                                                          | Type                                                        | Default  |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | -------- |
| target     | specifies the parent element. If it exists, it will trigger the `loadMore` when scrolling to the bottom. Needs to work with `isNoMore` to know when there is no more data to load. **when target is document, it is defined as the entire viewport** | `() => Element` \| `Element` \| `MutableRefObject<Element>` | -        |
| isNoMore   | determines if there is no more data, the input parameter is the latest merged `data`                                                                                                                                                                 | `(data?: TData) => boolean`                                 | -        |
| threshold  | The pixel threshold to the bottom for the scrolling to load                                                                                                                                                                                          | `number`                                                    | `100`    |
| direction  | The direction of the scrolling                                                                                                                                                                                                                       | `bottom` \|`top`                                            | `bottom` |
| reloadDeps | When the content of the array changes, `reload` will be triggered                                                                                                                                                                                    | `any[]`                                                     | -        |
| manual     | <ul><li> The default is `false`. That is, the service is automatically executed during initialization. </li><li>If set to `true`, you need to manually call `run` or `runAsync` to trigger execution </li></ul>                                      | `boolean`                                                   | `false`  |
| onBefore   | Triggered before service execution                                                                                                                                                                                                                   | `() => void`                                                | -        |
| onSuccess  | Triggered when service resolve                                                                                                                                                                                                                       | `(data: TData) => void`                                     | -        |
| onError    | Triggered when service reject                                                                                                                                                                                                                        | `(e: Error) => void`                                        | -        |
| onFinally  | Triggered when service execution is complete                                                                                                                                                                                                         | `(data?: TData, e?: Error) => void`                         | -        |
