{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "useVirtualList",
  "title": "useVirtualList",
  "description": "useVirtualList hook",
  "registryDependencies": [
    "useEventListener.json",
    "useMemoizedFn.json",
    "useSize.json",
    "utils.json",
    "useUpdateEffect.json"
  ],
  "files": [
    {
      "path": "packages/hooks/src/useVirtualList/index.ts",
      "content": "import { useEffect, useMemo, useState, useRef } from 'react';\nimport type { CSSProperties } from 'react';\nimport useEventListener from '../useEventListener';\nimport useLatest from '../useLatest';\nimport useMemoizedFn from '../useMemoizedFn';\nimport useSize from '../useSize';\nimport { getTargetElement } from '../utils/domTarget';\nimport type { BasicTarget } from '../utils/domTarget';\nimport { isNumber } from '../utils';\nimport useUpdateEffect from '../useUpdateEffect';\n\ntype ItemHeight<T> = (index: number, data: T) => number;\n\nexport interface Options<T> {\n  containerTarget: BasicTarget;\n  wrapperTarget: BasicTarget;\n  itemHeight: number | ItemHeight<T>;\n  overscan?: number;\n}\n\nconst useVirtualList = <T = any>(list: T[], options: Options<T>) => {\n  const { containerTarget, wrapperTarget, itemHeight, overscan = 5 } = options;\n\n  const itemHeightRef = useLatest(itemHeight);\n\n  const size = useSize(containerTarget);\n\n  const scrollTriggerByScrollToFunc = useRef(false);\n\n  const [targetList, setTargetList] = useState<{ index: number; data: T }[]>([]);\n\n  const [wrapperStyle, setWrapperStyle] = useState<CSSProperties>({});\n\n  const getVisibleCount = (containerHeight: number, fromIndex: number) => {\n    if (isNumber(itemHeightRef.current)) {\n      return Math.ceil(containerHeight / itemHeightRef.current);\n    }\n\n    let sum = 0;\n    let endIndex = 0;\n    for (let i = fromIndex; i < list.length; i++) {\n      const height = itemHeightRef.current(i, list[i]);\n      sum += height;\n      endIndex = i;\n      if (sum >= containerHeight) {\n        break;\n      }\n    }\n    return endIndex - fromIndex;\n  };\n\n  const getOffset = (scrollTop: number) => {\n    if (isNumber(itemHeightRef.current)) {\n      return Math.floor(scrollTop / itemHeightRef.current);\n    }\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < list.length; i++) {\n      const height = itemHeightRef.current(i, list[i]);\n      sum += height;\n      if (sum >= scrollTop) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n\n  // 获取上部高度\n  const getDistanceTop = (index: number) => {\n    if (isNumber(itemHeightRef.current)) {\n      const height = index * itemHeightRef.current;\n      return height;\n    }\n    const height = list\n      .slice(0, index)\n      .reduce<number>((sum, _, i) => sum + (itemHeightRef.current as ItemHeight<T>)(i, list[i]), 0);\n    return height;\n  };\n\n  const totalHeight = useMemo(() => {\n    if (isNumber(itemHeightRef.current)) {\n      return list.length * itemHeightRef.current;\n    }\n    return list.reduce<number>(\n      (sum, _, index) => sum + (itemHeightRef.current as ItemHeight<T>)(index, list[index]),\n      0,\n    );\n  }, [list]);\n\n  const calculateRange = () => {\n    const container = getTargetElement(containerTarget);\n\n    if (container) {\n      const { scrollTop, clientHeight } = container;\n\n      const offset = getOffset(scrollTop);\n      const visibleCount = getVisibleCount(clientHeight, offset);\n\n      const start = Math.max(0, offset - overscan);\n      const end = Math.min(list.length, offset + visibleCount + overscan);\n\n      const offsetTop = getDistanceTop(start);\n\n      setWrapperStyle({\n        height: totalHeight - offsetTop + 'px',\n        marginTop: offsetTop + 'px',\n      });\n\n      setTargetList(\n        list.slice(start, end).map((ele, index) => ({\n          data: ele,\n          index: index + start,\n        })),\n      );\n    }\n  };\n\n  useUpdateEffect(() => {\n    const wrapper = getTargetElement(wrapperTarget) as HTMLElement;\n    if (wrapper) {\n      Object.keys(wrapperStyle).forEach(\n        (key) => ((wrapper.style as any)[key] = (wrapperStyle as any)[key]),\n      );\n    }\n  }, [wrapperStyle]);\n\n  useEffect(() => {\n    if (!size?.width || !size?.height) {\n      return;\n    }\n    calculateRange();\n  }, [size?.width, size?.height, list]);\n\n  useEventListener(\n    'scroll',\n    (e) => {\n      if (scrollTriggerByScrollToFunc.current) {\n        scrollTriggerByScrollToFunc.current = false;\n        return;\n      }\n      e.preventDefault();\n      calculateRange();\n    },\n    {\n      target: containerTarget,\n    },\n  );\n\n  const scrollTo = (index: number) => {\n    const container = getTargetElement(containerTarget);\n    if (container) {\n      scrollTriggerByScrollToFunc.current = true;\n      container.scrollTop = getDistanceTop(index);\n      calculateRange();\n    }\n  };\n\n  return [targetList, useMemoizedFn(scrollTo)] as const;\n};\n\nexport default useVirtualList;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useVirtualList/index.ts"
    }
  ],
  "type": "registry:hook"
}
