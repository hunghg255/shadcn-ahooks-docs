{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "useRequest",
  "title": "useRequest",
  "description": "useRequest hook",
  "dependencies": [
    "es-toolkit"
  ],
  "registryDependencies": [
    "useUpdateEffect.json",
    "useUpdate.json",
    "useCreation.json",
    "useUnmount.json",
    "utils.json",
    "useLatest.json",
    "useMemoizedFn.json",
    "useMount.json"
  ],
  "files": [
    {
      "path": "packages/hooks/src/useRequest/index.ts",
      "content": "import useRequest from './src/useRequest';\nimport { clearCache } from './src/utils/cache';\n\nexport { clearCache };\n\nexport default useRequest;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/index.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/Fetch.ts",
      "content": "/* eslint-disable @typescript-eslint/no-parameter-properties */\nimport type { RefObject } from 'react';\nimport { isFunction } from '../../utils';\nimport type { FetchState, Options, PluginReturn, Service, Subscribe } from './types';\n\nexport default class Fetch<TData, TParams extends any[]> {\n  pluginImpls: PluginReturn<TData, TParams>[] = [];\n\n  count: number = 0;\n\n  state: FetchState<TData, TParams> = {\n    loading: false,\n    params: undefined,\n    data: undefined,\n    error: undefined,\n  };\n\n  constructor(\n    public serviceRef: RefObject<Service<TData, TParams>>,\n    public options: Options<TData, TParams>,\n    public subscribe: Subscribe,\n    public initState: Partial<FetchState<TData, TParams>> = {},\n  ) {\n    this.state = {\n      ...this.state,\n      loading: !options.manual,\n      ...initState,\n    };\n  }\n\n  setState(s: Partial<FetchState<TData, TParams>> = {}) {\n    this.state = {\n      ...this.state,\n      ...s,\n    };\n    this.subscribe();\n  }\n\n  runPluginHandler(event: keyof PluginReturn<TData, TParams>, ...rest: any[]) {\n    // @ts-ignore\n    const r = this.pluginImpls.map((i) => i[event]?.(...rest)).filter(Boolean);\n    return Object.assign({}, ...r);\n  }\n\n  async runAsync(...params: TParams): Promise<TData> {\n    this.count += 1;\n    const currentCount = this.count;\n\n    const {\n      stopNow = false,\n      returnNow = false,\n      ...state\n    } = this.runPluginHandler('onBefore', params);\n\n    // stop request\n    if (stopNow) {\n      return new Promise(() => {});\n    }\n\n    this.setState({\n      loading: true,\n      params,\n      ...state,\n    });\n\n    // return now\n    if (returnNow) {\n      return Promise.resolve(state.data);\n    }\n\n    this.options.onBefore?.(params);\n\n    try {\n      // replace service\n      let { servicePromise } = this.runPluginHandler('onRequest', this.serviceRef.current, params);\n\n      if (!servicePromise) {\n        servicePromise = this.serviceRef.current(...params);\n      }\n\n      const res = await servicePromise;\n\n      if (currentCount !== this.count) {\n        // prevent run.then when request is canceled\n        return new Promise(() => {});\n      }\n\n      // const formattedResult = this.options.formatResultRef.current ? this.options.formatResultRef.current(res) : res;\n\n      this.setState({\n        data: res,\n        error: undefined,\n        loading: false,\n      });\n\n      this.options.onSuccess?.(res, params);\n      this.runPluginHandler('onSuccess', res, params);\n\n      this.options.onFinally?.(params, res, undefined);\n\n      if (currentCount === this.count) {\n        this.runPluginHandler('onFinally', params, res, undefined);\n      }\n\n      return res;\n    } catch (error) {\n      if (currentCount !== this.count) {\n        // prevent run.then when request is canceled\n        return new Promise(() => {});\n      }\n\n      this.setState({\n        error: error as Error | undefined,\n        loading: false,\n      });\n\n      this.options.onError?.(error as Error, params);\n      this.runPluginHandler('onError', error, params);\n\n      this.options.onFinally?.(params, undefined, error as Error | undefined);\n\n      if (currentCount === this.count) {\n        this.runPluginHandler('onFinally', params, undefined, error);\n      }\n\n      throw error;\n    }\n  }\n\n  run(...params: TParams) {\n    this.runAsync(...params).catch((error) => {\n      if (!this.options.onError) {\n        console.error(error);\n      }\n    });\n  }\n\n  cancel() {\n    this.count += 1;\n    this.setState({\n      loading: false,\n    });\n\n    this.runPluginHandler('onCancel');\n  }\n\n  refresh() {\n    // @ts-ignore\n    this.run(...(this.state.params || []));\n  }\n\n  refreshAsync() {\n    // @ts-ignore\n    return this.runAsync(...(this.state.params || []));\n  }\n\n  mutate(data?: TData | ((oldData?: TData) => TData | undefined)) {\n    const targetData = isFunction(data) ? data(this.state.data) : data;\n    this.runPluginHandler('onMutate', targetData);\n    this.setState({\n      data: targetData,\n    });\n  }\n}\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/Fetch.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/types.ts",
      "content": "import type { DependencyList } from 'react';\nimport type Fetch from './Fetch';\nimport type { CachedData } from './utils/cache';\n\nexport type Service<TData, TParams extends any[]> = (...args: TParams) => Promise<TData>;\nexport type Subscribe = () => void;\n\n// for Fetch\n\nexport interface FetchState<TData, TParams extends any[]> {\n  loading: boolean;\n  params?: TParams;\n  data?: TData;\n  error?: Error;\n}\n\nexport interface PluginReturn<TData, TParams extends any[]> {\n  onBefore?: (params: TParams) =>\n    | ({\n        stopNow?: boolean;\n        returnNow?: boolean;\n      } & Partial<FetchState<TData, TParams>>)\n    | void;\n\n  onRequest?: (\n    service: Service<TData, TParams>,\n    params: TParams,\n  ) => {\n    servicePromise?: Promise<TData>;\n  };\n\n  onSuccess?: (data: TData, params: TParams) => void;\n  onError?: (e: Error, params: TParams) => void;\n  onFinally?: (params: TParams, data?: TData, e?: Error) => void;\n  onCancel?: () => void;\n  onMutate?: (data: TData) => void;\n}\n\n// for useRequestImplement\n\nexport interface Options<TData, TParams extends any[]> {\n  manual?: boolean;\n\n  onBefore?: (params: TParams) => void;\n  onSuccess?: (data: TData, params: TParams) => void;\n  onError?: (e: Error, params: TParams) => void;\n  // formatResult?: (res: any) => TData;\n  onFinally?: (params: TParams, data?: TData, e?: Error) => void;\n\n  defaultParams?: TParams;\n\n  // refreshDeps\n  refreshDeps?: DependencyList;\n  refreshDepsAction?: () => void;\n\n  // loading delay\n  loadingDelay?: number;\n\n  // polling\n  pollingInterval?: number;\n  pollingWhenHidden?: boolean;\n  pollingErrorRetryCount?: number;\n  pollingIntervalWhen?: (data: TData, error: Error | undefined) => number | false | undefined;\n\n  // refresh on window focus\n  refreshOnWindowFocus?: boolean;\n  focusTimespan?: number;\n\n  // debounce\n  debounceWait?: number;\n  debounceLeading?: boolean;\n  debounceTrailing?: boolean;\n  debounceMaxWait?: number;\n\n  // throttle\n  throttleWait?: number;\n  throttleLeading?: boolean;\n  throttleTrailing?: boolean;\n\n  // cache\n  cacheKey?: string;\n  cacheTime?: number;\n  staleTime?: number;\n  setCache?: (data: CachedData<TData, TParams>) => void;\n  getCache?: (params: TParams) => CachedData<TData, TParams> | undefined;\n\n  // retry\n  retryCount?: number;\n  retryInterval?: number;\n\n  // ready\n  ready?: boolean;\n\n  // [key: string]: any;\n}\n\nexport type Plugin<TData, TParams extends any[]> = {\n  (\n    fetchInstance: Fetch<TData, TParams>,\n    options: Options<TData, TParams>,\n  ): PluginReturn<TData, TParams>;\n  onInit?: (options: Options<TData, TParams>) => Partial<FetchState<TData, TParams>>;\n};\n\n// for index\n// export type OptionsWithoutFormat<TData, TParams extends any[]> = Omit<Options<TData, TParams>, 'formatResult'>;\n\n// export interface OptionsWithFormat<TData, TParams extends any[], TFormated, TTFormated extends TFormated = any> extends Omit<Options<TTFormated, TParams>, 'formatResult'> {\n//   formatResult: (res: TData) => TFormated;\n// };\n\nexport interface Result<TData, TParams extends any[]> {\n  loading: boolean;\n  data?: TData;\n  error?: Error;\n  params: TParams | [];\n  cancel: Fetch<TData, TParams>['cancel'];\n  refresh: Fetch<TData, TParams>['refresh'];\n  refreshAsync: Fetch<TData, TParams>['refreshAsync'];\n  run: Fetch<TData, TParams>['run'];\n  runAsync: Fetch<TData, TParams>['runAsync'];\n  mutate: Fetch<TData, TParams>['mutate'];\n}\n\nexport type Timeout = ReturnType<typeof setTimeout>;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/types.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/useRequest.ts",
      "content": "import useAutoRunPlugin from './plugins/useAutoRunPlugin';\nimport useCachePlugin from './plugins/useCachePlugin';\nimport useDebouncePlugin from './plugins/useDebouncePlugin';\nimport useLoadingDelayPlugin from './plugins/useLoadingDelayPlugin';\nimport usePollingPlugin from './plugins/usePollingPlugin';\nimport useRefreshOnWindowFocusPlugin from './plugins/useRefreshOnWindowFocusPlugin';\nimport useRetryPlugin from './plugins/useRetryPlugin';\nimport useThrottlePlugin from './plugins/useThrottlePlugin';\nimport type { Options, Plugin, Service } from './types';\nimport useRequestImplement from './useRequestImplement';\n\n// function useRequest<TData, TParams extends any[], TFormated, TTFormated extends TFormated = any>(\n//   service: Service<TData, TParams>,\n//   options: OptionsWithFormat<TData, TParams, TFormated, TTFormated>,\n//   plugins?: Plugin<TData, TParams>[],\n// ): Result<TFormated, TParams>\n// function useRequest<TData, TParams extends any[]>(\n//   service: Service<TData, TParams>,\n//   options?: OptionsWithoutFormat<TData, TParams>,\n//   plugins?: Plugin<TData, TParams>[],\n// ): Result<TData, TParams>\nfunction useRequest<TData, TParams extends any[]>(\n  service: Service<TData, TParams>,\n  options?: Options<TData, TParams>,\n  plugins?: Plugin<TData, TParams>[],\n) {\n  return useRequestImplement<TData, TParams>(service, options, [\n    ...(plugins || []),\n    useDebouncePlugin,\n    useLoadingDelayPlugin,\n    usePollingPlugin,\n    useRefreshOnWindowFocusPlugin,\n    useThrottlePlugin,\n    useAutoRunPlugin,\n    useCachePlugin,\n    useRetryPlugin,\n  ] as Plugin<TData, TParams>[]);\n}\n\nexport default useRequest;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/useRequest.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/useRequestImplement.ts",
      "content": "import useCreation from '../../useCreation';\nimport useLatest from '../../useLatest';\nimport useMemoizedFn from '../../useMemoizedFn';\nimport useMount from '../../useMount';\nimport useUnmount from '../../useUnmount';\nimport useUpdate from '../../useUpdate';\nimport isDev from '../../utils/isDev';\n\nimport Fetch from './Fetch';\nimport type { Options, Plugin, Result, Service } from './types';\n\nfunction useRequestImplement<TData, TParams extends any[]>(\n  service: Service<TData, TParams>,\n  options: Options<TData, TParams> = {},\n  plugins: Plugin<TData, TParams>[] = [],\n) {\n  const { manual = false, ready = true, ...rest } = options;\n\n  if (isDev) {\n    if (options.defaultParams && !Array.isArray(options.defaultParams)) {\n      console.warn(`expected defaultParams is array, got ${typeof options.defaultParams}`);\n    }\n  }\n\n  const fetchOptions = {\n    manual,\n    ready,\n    ...rest,\n  };\n\n  const serviceRef = useLatest(service);\n\n  const update = useUpdate();\n\n  const fetchInstance = useCreation(() => {\n    const initState = plugins.map((p) => p?.onInit?.(fetchOptions)).filter(Boolean);\n\n    return new Fetch<TData, TParams>(\n      serviceRef,\n      fetchOptions,\n      update,\n      Object.assign({}, ...initState),\n    );\n  }, []);\n  fetchInstance.options = fetchOptions;\n  // run all plugins hooks\n  fetchInstance.pluginImpls = plugins.map((p) => p(fetchInstance, fetchOptions));\n\n  useMount(() => {\n    if (!manual && ready) {\n      // useCachePlugin can set fetchInstance.state.params from cache when init\n      const params = fetchInstance.state.params || options.defaultParams || [];\n      // @ts-ignore\n      fetchInstance.run(...params);\n    }\n  });\n\n  useUnmount(() => {\n    fetchInstance.cancel();\n  });\n\n  return {\n    loading: fetchInstance.state.loading,\n    data: fetchInstance.state.data,\n    error: fetchInstance.state.error,\n    params: fetchInstance.state.params || [],\n    cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),\n    refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),\n    refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),\n    run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),\n    runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),\n    mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance)),\n  } as Result<TData, TParams>;\n}\n\nexport default useRequestImplement;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/useRequestImplement.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useAutoRunPlugin.ts",
      "content": "import { useRef } from 'react';\nimport useUpdateEffect from '../../../useUpdateEffect';\nimport type { Plugin } from '../types';\n\n// support refreshDeps & ready\nconst useAutoRunPlugin: Plugin<any, any[]> = (\n  fetchInstance,\n  { manual, ready = true, defaultParams = [], refreshDeps = [], refreshDepsAction },\n) => {\n  const hasAutoRun = useRef<boolean>(false);\n  hasAutoRun.current = false;\n\n  useUpdateEffect(() => {\n    if (!manual && ready) {\n      hasAutoRun.current = true;\n      fetchInstance.run(...defaultParams);\n    }\n  }, [ready]);\n\n  useUpdateEffect(() => {\n    if (hasAutoRun.current) {\n      return;\n    }\n    if (!manual) {\n      hasAutoRun.current = true;\n      if (refreshDepsAction) {\n        refreshDepsAction();\n      } else {\n        fetchInstance.refresh();\n      }\n    }\n  }, [...refreshDeps]);\n\n  return {\n    onBefore: () => {\n      if (!ready) {\n        return {\n          stopNow: true,\n        };\n      }\n    },\n  };\n};\n\nuseAutoRunPlugin.onInit = ({ ready = true, manual }) => {\n  return {\n    loading: !manual && ready,\n  };\n};\n\nexport default useAutoRunPlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useAutoRunPlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useCachePlugin.ts",
      "content": "import { useRef } from 'react';\nimport useCreation from '../../../useCreation';\nimport useUnmount from '../../../useUnmount';\nimport type { Plugin } from '../types';\nimport { setCache, getCache } from '../utils/cache';\nimport type { CachedData } from '../utils/cache';\nimport { setCachePromise, getCachePromise } from '../utils/cachePromise';\nimport { trigger, subscribe } from '../utils/cacheSubscribe';\n\nconst useCachePlugin: Plugin<any, any[]> = (\n  fetchInstance,\n  {\n    cacheKey,\n    cacheTime = 5 * 60 * 1000,\n    staleTime = 0,\n    setCache: customSetCache,\n    getCache: customGetCache,\n  },\n) => {\n  const unSubscribeRef = useRef<() => void>(undefined);\n\n  const currentPromiseRef = useRef<Promise<any>>(undefined);\n\n  const _setCache = (key: string, cachedData: CachedData) => {\n    if (customSetCache) {\n      customSetCache(cachedData);\n    } else {\n      setCache(key, cacheTime, cachedData);\n    }\n    trigger(key, cachedData.data);\n  };\n\n  const _getCache = (key: string, params: any[] = []) => {\n    if (customGetCache) {\n      return customGetCache(params);\n    }\n    return getCache(key);\n  };\n\n  useCreation(() => {\n    if (!cacheKey) {\n      return;\n    }\n\n    // get data from cache when init\n    const cacheData = _getCache(cacheKey);\n    if (cacheData && Object.hasOwnProperty.call(cacheData, 'data')) {\n      fetchInstance.state.data = cacheData.data;\n      fetchInstance.state.params = cacheData.params;\n      if (staleTime === -1 || Date.now() - cacheData.time <= staleTime) {\n        fetchInstance.state.loading = false;\n      }\n    }\n\n    // subscribe same cachekey update, trigger update\n    unSubscribeRef.current = subscribe(cacheKey, (data) => {\n      fetchInstance.setState({ data });\n    });\n  }, []);\n\n  useUnmount(() => {\n    unSubscribeRef.current?.();\n  });\n\n  if (!cacheKey) {\n    return {};\n  }\n\n  return {\n    onBefore: (params) => {\n      const cacheData = _getCache(cacheKey, params);\n\n      if (!cacheData || !Object.hasOwnProperty.call(cacheData, 'data')) {\n        return {};\n      }\n\n      // If the data is fresh, stop request\n      if (staleTime === -1 || Date.now() - cacheData.time <= staleTime) {\n        return {\n          loading: false,\n          data: cacheData?.data,\n          error: undefined,\n          returnNow: true,\n        };\n      } else {\n        // If the data is stale, return data, and request continue\n        return {\n          data: cacheData?.data,\n          error: undefined,\n        };\n      }\n    },\n    onRequest: (service, args) => {\n      let servicePromise = getCachePromise(cacheKey);\n\n      // If has servicePromise, and is not trigger by self, then use it\n      if (servicePromise && servicePromise !== currentPromiseRef.current) {\n        return { servicePromise };\n      }\n\n      servicePromise = service(...args);\n      currentPromiseRef.current = servicePromise;\n      setCachePromise(cacheKey, servicePromise);\n      return { servicePromise };\n    },\n    onSuccess: (data, params) => {\n      if (cacheKey) {\n        // cancel subscribe, avoid trgger self\n        unSubscribeRef.current?.();\n        _setCache(cacheKey, {\n          data,\n          params,\n          time: Date.now(),\n        });\n        // resubscribe\n        unSubscribeRef.current = subscribe(cacheKey, (d) => {\n          fetchInstance.setState({ data: d });\n        });\n      }\n    },\n    onMutate: (data) => {\n      if (cacheKey) {\n        // cancel subscribe, avoid trigger self\n        unSubscribeRef.current?.();\n        _setCache(cacheKey, {\n          data,\n          params: fetchInstance.state.params,\n          time: Date.now(),\n        });\n        // resubscribe\n        unSubscribeRef.current = subscribe(cacheKey, (d) => {\n          fetchInstance.setState({ data: d });\n        });\n      }\n    },\n  };\n};\n\nexport default useCachePlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useCachePlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useDebouncePlugin.ts",
      "content": "import { debounce, type DebouncedFunc } from 'es-toolkit/compat';\nimport { useEffect, useMemo, useRef } from 'react';\nimport type { Plugin } from '../types';\n\ninterface DebounceSettings {\n    /**\n     * If `true`, the function will be invoked on the leading edge of the timeout.\n     * @default false\n     */\n    leading?: boolean | undefined;\n    /**\n     * The maximum time `func` is allowed to be delayed before it's invoked.\n     * @default Infinity\n     */\n    maxWait?: number | undefined;\n    /**\n     * If `true`, the function will be invoked on the trailing edge of the timeout.\n     * @default true\n     */\n    trailing?: boolean | undefined;\n}\n\nconst useDebouncePlugin: Plugin<any, any[]> = (\n  fetchInstance,\n  { debounceWait, debounceLeading, debounceTrailing, debounceMaxWait },\n) => {\n  const debouncedRef = useRef<DebouncedFunc<any>>(undefined);\n\n  const options = useMemo(() => {\n    const ret: DebounceSettings = {};\n    if (debounceLeading !== undefined) {\n      ret.leading = debounceLeading;\n    }\n    if (debounceTrailing !== undefined) {\n      ret.trailing = debounceTrailing;\n    }\n    if (debounceMaxWait !== undefined) {\n      ret.maxWait = debounceMaxWait;\n    }\n    return ret;\n  }, [debounceLeading, debounceTrailing, debounceMaxWait]);\n\n  useEffect(() => {\n    if (debounceWait) {\n      const _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);\n\n      debouncedRef.current = debounce(\n        (callback: (...args: any[]) => void) => {\n          callback();\n        },\n        debounceWait,\n        options,\n      );\n\n      // debounce runAsync should be promise\n      // https://github.com/lodash/lodash/issues/4400#issuecomment-834800398\n      fetchInstance.runAsync = (...args) => {\n        return new Promise<void>((resolve, reject) => {\n          debouncedRef.current?.(() => {\n            _originRunAsync(...args)\n              .then(resolve)\n              .catch(reject);\n          });\n        });\n      };\n\n      return () => {\n        debouncedRef.current?.cancel();\n        fetchInstance.runAsync = _originRunAsync;\n      };\n    }\n  }, [debounceWait, options]);\n\n  if (!debounceWait) {\n    return {};\n  }\n\n  return {\n    onCancel: () => {\n      debouncedRef.current?.cancel();\n    },\n  };\n};\n\nexport default useDebouncePlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useDebouncePlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useLoadingDelayPlugin.ts",
      "content": "import { useRef } from 'react';\nimport type { Plugin, Timeout } from '../types';\n\nconst useLoadingDelayPlugin: Plugin<any, any[]> = (fetchInstance, { loadingDelay, ready }) => {\n  const timerRef = useRef<Timeout>(undefined);\n\n  if (!loadingDelay) {\n    return {};\n  }\n\n  const cancelTimeout = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n  };\n\n  return {\n    onBefore: () => {\n      cancelTimeout();\n\n      // Two cases:\n      // 1. ready === undefined\n      // 2. ready === true\n      if (ready !== false) {\n        timerRef.current = setTimeout(() => {\n          fetchInstance.setState({\n            loading: true,\n          });\n        }, loadingDelay);\n      }\n\n      return {\n        loading: false,\n      };\n    },\n    onFinally: () => {\n      cancelTimeout();\n    },\n    onCancel: () => {\n      cancelTimeout();\n    },\n  };\n};\n\nexport default useLoadingDelayPlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useLoadingDelayPlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/usePollingPlugin.ts",
      "content": "import { useRef } from 'react';\nimport useUpdateEffect from '../../../useUpdateEffect';\nimport type { Plugin, Timeout } from '../types';\nimport isDocumentVisible from '../utils/isDocumentVisible';\nimport subscribeReVisible from '../utils/subscribeReVisible';\n\nconst usePollingPlugin: Plugin<any, any[]> = (\n  fetchInstance,\n  { pollingInterval, pollingWhenHidden = true, pollingErrorRetryCount = -1, pollingIntervalWhen },\n) => {\n  const timerRef = useRef<Timeout>(undefined);\n  const unsubscribeRef = useRef<() => void>(undefined);\n  const countRef = useRef<number>(0);\n\n  const stopPolling = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n    unsubscribeRef.current?.();\n  };\n\n  useUpdateEffect(() => {\n    if (!pollingInterval) {\n      stopPolling();\n    }\n  }, [pollingInterval]);\n\n  if (!pollingInterval && !pollingIntervalWhen) {\n    return {};\n  }\n\n  return {\n    onBefore: () => {\n      stopPolling();\n    },\n    onError: () => {\n      countRef.current += 1;\n    },\n    onSuccess: () => {\n      countRef.current = 0;\n    },\n    onFinally: () => {\n      let interval: number | false | undefined = pollingInterval;\n      if (pollingIntervalWhen) {\n\n        interval = pollingIntervalWhen(\n          fetchInstance.state.data,\n          fetchInstance.state.error,\n        );\n      }\n\n      if (!interval) {\n        stopPolling();\n        return;\n      }\n\n      if (\n        pollingErrorRetryCount === -1 ||\n        // When an error occurs, the request is not repeated after pollingErrorRetryCount retries\n        (pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount)\n      ) {\n        timerRef.current = setTimeout(() => {\n          // if pollingWhenHidden = false && document is hidden, then stop polling and subscribe revisible\n          if (!pollingWhenHidden && !isDocumentVisible()) {\n            unsubscribeRef.current = subscribeReVisible(() => {\n              fetchInstance.refresh();\n\n            });\n          } else {\n            fetchInstance.refresh();\n          }\n        }, interval);\n      } else {\n        countRef.current = 0;\n      }\n    },\n    onCancel: () => {\n      stopPolling();\n    },\n  };\n};\n\nexport default usePollingPlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/usePollingPlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useRefreshOnWindowFocusPlugin.ts",
      "content": "import { useEffect, useRef } from 'react';\nimport useUnmount from '../../../useUnmount';\nimport type { Plugin } from '../types';\nimport limit from '../utils/limit';\nimport subscribeFocus from '../utils/subscribeFocus';\n\nconst useRefreshOnWindowFocusPlugin: Plugin<any, any[]> = (\n  fetchInstance,\n  { refreshOnWindowFocus, focusTimespan = 5000 },\n) => {\n  const unsubscribeRef = useRef<() => void>(undefined);\n\n  const stopSubscribe = () => {\n    unsubscribeRef.current?.();\n  };\n\n  useEffect(() => {\n    if (refreshOnWindowFocus) {\n      const limitRefresh = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);\n      unsubscribeRef.current = subscribeFocus(() => {\n        limitRefresh();\n      });\n    }\n    return () => {\n      stopSubscribe();\n    };\n  }, [refreshOnWindowFocus, focusTimespan]);\n\n  useUnmount(() => {\n    stopSubscribe();\n  });\n\n  return {};\n};\n\nexport default useRefreshOnWindowFocusPlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useRefreshOnWindowFocusPlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useRetryPlugin.ts",
      "content": "import { useRef } from 'react';\nimport type { Plugin } from '../types';\n\nconst useRetryPlugin: Plugin<any, any[]> = (fetchInstance, { retryInterval, retryCount }) => {\n  const timerRef = useRef<ReturnType<typeof setTimeout>>(undefined);\n  const countRef = useRef<number>(0);\n\n  const triggerByRetry = useRef(false);\n\n  if (!retryCount) {\n    return {};\n  }\n\n  return {\n    onBefore: () => {\n      if (!triggerByRetry.current) {\n        countRef.current = 0;\n      }\n      triggerByRetry.current = false;\n\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    },\n    onSuccess: () => {\n      countRef.current = 0;\n    },\n    onError: () => {\n      countRef.current += 1;\n      if (retryCount === -1 || countRef.current <= retryCount) {\n        // Exponential backoff\n        const timeout = retryInterval ?? Math.min(1000 * 2 ** countRef.current, 30000);\n        timerRef.current = setTimeout(() => {\n          triggerByRetry.current = true;\n          fetchInstance.refresh();\n        }, timeout);\n      } else {\n        countRef.current = 0;\n      }\n    },\n    onCancel: () => {\n      countRef.current = 0;\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    },\n  };\n};\n\nexport default useRetryPlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useRetryPlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/plugins/useThrottlePlugin.ts",
      "content": "import { throttle, type DebouncedFunc } from 'es-toolkit/compat';\nimport { useEffect, useRef } from 'react';\nimport type { Plugin } from '../types';\n\ninterface ThrottleSettings {\n  /**\n   * @see _.leading\n   */\n  leading?: boolean | undefined;\n  /**\n   * @see _.trailing\n   */\n  trailing?: boolean | undefined;\n}\n\nconst useThrottlePlugin: Plugin<any, any[]> = (\n  fetchInstance,\n  { throttleWait, throttleLeading, throttleTrailing },\n) => {\n  const throttledRef = useRef<DebouncedFunc<any>>(undefined);\n\n  const options: ThrottleSettings = {};\n\n  if (throttleLeading !== undefined) {\n    options.leading = throttleLeading;\n  }\n  if (throttleTrailing !== undefined) {\n    options.trailing = throttleTrailing;\n  }\n\n  useEffect(() => {\n    if (throttleWait) {\n      const _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);\n\n      throttledRef.current = throttle(\n        (callback) => {\n          callback();\n        },\n        throttleWait,\n        options,\n      );\n\n      // throttle runAsync should be promise\n      // https://github.com/lodash/lodash/issues/4400#issuecomment-834800398\n      fetchInstance.runAsync = (...args) => {\n        return new Promise((resolve, reject) => {\n          throttledRef.current?.(() => {\n            _originRunAsync(...args)\n              .then(resolve)\n              .catch(reject);\n          });\n        });\n      };\n\n      return () => {\n        fetchInstance.runAsync = _originRunAsync;\n        throttledRef.current?.cancel();\n      };\n    }\n  }, [throttleWait, throttleLeading, throttleTrailing]);\n\n  if (!throttleWait) {\n    return {};\n  }\n\n  return {\n    onCancel: () => {\n      throttledRef.current?.cancel();\n    },\n  };\n};\n\nexport default useThrottlePlugin;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/plugins/useThrottlePlugin.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/cache.ts",
      "content": "type Timer = ReturnType<typeof setTimeout>;\ntype CachedKey = string | number;\n\nexport interface CachedData<TData = any, TParams = any> {\n  data: TData;\n  params: TParams;\n  time: number;\n}\ninterface RecordData extends CachedData {\n  timer: Timer | undefined;\n}\n\nconst cache = new Map<CachedKey, RecordData>();\n\nconst setCache = (key: CachedKey, cacheTime: number, cachedData: CachedData) => {\n  const currentCache = cache.get(key);\n  if (currentCache?.timer) {\n    clearTimeout(currentCache.timer);\n  }\n\n  let timer: Timer | undefined = undefined;\n\n  if (cacheTime > -1) {\n    // if cache out, clear it\n    timer = setTimeout(() => {\n      cache.delete(key);\n    }, cacheTime);\n  }\n\n  cache.set(key, {\n    ...cachedData,\n    timer,\n  });\n};\n\nconst getCache = (key: CachedKey) => {\n  return cache.get(key);\n};\n\nconst clearCache = (key?: string | string[]) => {\n  if (key) {\n    const cacheKeys = Array.isArray(key) ? key : [key];\n    cacheKeys.forEach((cacheKey) => cache.delete(cacheKey));\n  } else {\n    cache.clear();\n  }\n};\n\nexport { getCache, setCache, clearCache };\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/cache.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/cachePromise.ts",
      "content": "type CachedKey = string | number;\nconst cachePromise = new Map<CachedKey, Promise<any>>();\n\nconst getCachePromise = (cacheKey: CachedKey) => {\n  return cachePromise.get(cacheKey);\n};\n\nconst setCachePromise = (cacheKey: CachedKey, promise: Promise<any>) => {\n  // Should cache the same promise, cannot be promise.finally\n  // Because the promise.finally will change the reference of the promise\n  cachePromise.set(cacheKey, promise);\n\n  // no use promise.finally for compatibility\n  promise\n    .then((res) => {\n      cachePromise.delete(cacheKey);\n      return res;\n    })\n    .catch(() => {\n      cachePromise.delete(cacheKey);\n    });\n};\n\nexport { getCachePromise, setCachePromise };\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/cachePromise.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/cacheSubscribe.ts",
      "content": "type Listener = (data: any) => void;\nconst listeners: Record<string, Listener[]> = {};\n\nconst trigger = (key: string, data: any) => {\n  if (listeners[key]) {\n    listeners[key].forEach((item) => item(data));\n  }\n};\n\nconst subscribe = (key: string, listener: Listener) => {\n  if (!listeners[key]) {\n    listeners[key] = [];\n  }\n  listeners[key].push(listener);\n\n  return function unsubscribe() {\n    const index = listeners[key].indexOf(listener);\n    listeners[key].splice(index, 1);\n  };\n};\n\nexport { trigger, subscribe };\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/cacheSubscribe.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/isDocumentVisible.ts",
      "content": "import isBrowser from '../../../utils/isBrowser';\n\nexport default function isDocumentVisible(): boolean {\n  if (isBrowser) {\n    return document.visibilityState !== 'hidden';\n  }\n  return true;\n}\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/isDocumentVisible.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/isOnline.ts",
      "content": "import isBrowser from '../../../utils/isBrowser';\n\nconst isOnline = () => {\n  if (isBrowser && typeof navigator.onLine !== 'undefined') {\n    return navigator.onLine;\n  }\n  return true;\n};\n\nexport default isOnline;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/isOnline.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/limit.ts",
      "content": "export default function limit(fn: any, timespan: number) {\n  let pending = false;\n  return (...args: any[]) => {\n    if (pending) return;\n    pending = true;\n    fn(...args);\n    setTimeout(() => {\n      pending = false;\n    }, timespan);\n  };\n}\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/limit.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/subscribeFocus.ts",
      "content": "// from swr\nimport isBrowser from '../../../utils/isBrowser';\nimport isDocumentVisible from './isDocumentVisible';\nimport isOnline from './isOnline';\n\ntype Listener = () => void;\n\nconst listeners = new Set<Listener>();\n\nfunction subscribe(listener: Listener) {\n  listeners.add(listener);\n  return function unsubscribe() {\n    listeners.has(listener) && listeners.delete(listener);\n  };\n}\n\nif (isBrowser) {\n  const revalidate = () => {\n    if (!isDocumentVisible() || !isOnline()) return;\n    listeners.forEach((listener) => listener());\n  };\n  window.addEventListener('visibilitychange', revalidate, false);\n  window.addEventListener('focus', revalidate, false);\n}\n\nexport default subscribe;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/subscribeFocus.ts"
    },
    {
      "path": "packages/hooks/src/useRequest/src/utils/subscribeReVisible.ts",
      "content": "import isBrowser from '../../../utils/isBrowser';\nimport isDocumentVisible from './isDocumentVisible';\n\ntype Listener = () => void;\n\nconst listeners = new Set<Listener>();\n\nfunction subscribe(listener: Listener) {\n  listeners.add(listener);\n  return function unsubscribe() {\n    listeners.has(listener) && listeners.delete(listener);\n  };\n}\n\nif (isBrowser) {\n  const revalidate = () => {\n    if (!isDocumentVisible()) return;\n    listeners.forEach((listener) => listener());\n  };\n  window.addEventListener('visibilitychange', revalidate, false);\n}\n\nexport default subscribe;\n",
      "type": "registry:file",
      "target": "src/hooks/ahooks/useRequest/src/utils/subscribeReVisible.ts"
    }
  ],
  "type": "registry:hook"
}
